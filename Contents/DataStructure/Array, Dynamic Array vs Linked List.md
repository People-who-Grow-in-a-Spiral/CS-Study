# Array는 어떤 자료구조인가?

## 핵심 개념
Array는 연관된 데이터를 **메모리상에 연속적이며 순차적으로 미리 할당된 크기**만큼 저장하는 자료구조입니다.

---

## 면접 대비 핵심 포인트💡
**Array vs Linked List**의 비교되는 특징
1. **메모리에 저장되는 방식**
2. 1번에 따른 **operation의 연산 속도(time complexity)**<br>
(이후 Linked List를 하고 추가 예정)
---

## Array의 특징
-핵심 특징 : **고정된 저장 공간**에 **순차적인 데이터 저장**을 한다.

- Array의 장점 : **lookup**과 **append**가 빠르다.  
-> **조회를 자주 해야 하는 작업**일 때 자주 Array 자료구조를 자주 사용한다.

- Array의 단점 : **저장 공간이 고정되어 있음으로 Array의 크기를 미리 정해야** 한다.  
-> 이는 메모리 낭비나 추가적인 **overhead(작업 시간 소요)** 가 발생할 수 있다.

---

## 시간복잡도
⚠️ 핵심 특징 : **고정된 저장 공간**에 **순차적인 데이터 저장**을 기억하며 계산하자!
<img width="524" alt="image" src="https://github.com/user-attachments/assets/e2393ef3-621d-4823-ae08-ed8a6019d855">


### 접근(access) 탐색(search)
✅ 접근 혹은 탐색하려는 **인덱스 값을 알고 있으므로 `O(1)`**<br>
✅ 접근 혹은 탐색하려는 **인덱스 값을 모르면 `O(n)`**

### 추가(append)와 삽입(insertion)
추가하려는 데이터의 **위치가 맨 뒤이고 배열에 공간이 남아있다면, `O(1)`**<br>
추가하려는 데이터가 **위치가 맨 뒤가 아니면**, 추가되는 데이터 위치 이후에 있는 **모든 데이터들을 한 칸씩 미뤄야하므로 `O(n)`**<br>
추가하려는 데이터가 **공간이 남아 있지 않다면**, **크기를 늘릴 수 없어서 새로 만들어야하므로 `O(n)`**

### 삭제(deletion)
삭제하려는 데이터의 **위치가 맨 뒤이고 배열에 공간이 남아있다면, `O(1)`**<br>
삭제하려는 데이터의 **위치가 맨 뒤가 아니라면, 새로 만들어야하므로 `O(n)`**

---

## 꼬리 질문
**Q)** 예상보다 데이터를 저장하느라 Array의 size를 넘어서게되었다. 이 때, 어떻게 해결 방법은?

---
<br><br><br>

# Dynamic Array는 어떤 자료구조인가?

## 핵심 개념
Array는 **size가 고정**되었기 때문에 선언 시에 설정한 size보다 많은 개수의 data가 추가되면 저장할 수 없습니다.  
이에 반해 **Dynamic Array**는 저장공간이 가득 차게 되면 **resize**를 하여 유동적으로 size를 조절하며 데이터를 저장하는 자료구조입니다.

---

## 면접 대비 핵심 포인트💡 
Array의 특징 중에 **fixed-size의 한계점**을 보완하고자 고안된 자료구조인 **Dynamic Array**에 대한 공부 포인트.
1. **resize를 하는 방식**
2. **데이터 추가(append)할 때의 시간복잡도**

---

# Dynamic Array

**개념** : Dynamic Array는 **size**를 자동적으로 **resizing**하는 Array이다.
고정된 사이즈를 가진 Static Array의 한계점을 보완하고자 고안되었다.

**방식** : **Resizing**
1. 데이터를 계속 **추가(append)** 하다가 기존에 할당된 메모리를 초과한다.
2. **size를 늘린 배열을 선언**하고 그것으로 모든 데이터를 일일이 옮긴다.
   
-> 따라서 Dynamic Array는 size를 미리 고민할 필요가 없다.
(물론, resizing시마다 개발적으로 좋진 않다.)

---

# Doubling

**개념** : resize의 대표적인 방법을 기존 Array **size의 2배**로 늘린다.(컴퓨터의 default 방식이다.)
**시간 복잡도** : **n개의 데이터를 옮겨야 하기 때문에, `O(n)`**

---

# 데이터 추가(append)할 때의 시간복잡도는?

❓ Dynamic Array에 데이터를 추가할 때마다 `O(1)`의 시간이 걸린다.
하지만 **추가를 하다가 미리 선언된 size를 넘어서게 되는 순간**에 **resize**를 하게 되며, 이때는는 **모든 데이터를 옮겨야 하므로, `O(n)`의 시간**이 걸린다.
그렇다면 결과적으로 **append**의 시간복잡도는 `O(1)`일까? 아니면 `O(n)`일까?


## 분할상환 시간복잡도 (Amortized Time Complexity)

✅ 쉽게 말하자면, 가끔 발생하는 `O(n)`의 시간을 자주 발생하는 `O(1)`의 작업들에 **분산**해서 전체적으로 **평균 `O(1)`의 시간이 걸린다고 생각**한다.

- Append의 전체 과정에서는 데이터를 마지막 인덱스에 추가하는 `O(1)` 작업이 대부분이다.  
- 하지만 size를 넘어서게 되는 상황에서는 데이터를 옮기는 작업(`resize O(n)`)이 발생한다.  
- 이 작업은 아주 가끔 발생하므로, 전체적으로 `append`의 **평균적인 시간복잡도는 `O(1)`**.

이를 조금 더 정확히 표현하면 **Amortized O(1)** 이라고 부른다.

---

## 꼬리 질문
**Q)** Dynamic Array vs Linked List 장단점을 비교하라

