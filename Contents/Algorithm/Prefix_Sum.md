# 누적합 알고리즘(Prefix Sum Algorithm)

## 누적합의 개념
- 수열 An에 대해서 첫 인덱스부터 각 인덱스까지의 합을 나타내는 말
- 배열 A가 [1,2,3,4,5] 일 때, A의 누적합을 배열로 나타내면 [1,3,6,10,15] 이다.

    ****배열의 값들이 수정되지 않는다는 것을 조건으로 가진다.***

    ### 구간합(Range Sum)
    - 배열의 [A ~ B] 범위의 구간합을 구하고자 할 때, 누적합 배열을 만들어 [B]까지의 누적합에서 [A - 1]까지의 누적합을 빼주면 [A ~ B] 범위의 구간합을 구할 수 있다. 
    - 누적합 배열에 상수 k(배열의 차원에 따라 달라짐)번 접근하여 연산하면 되기 때문에 시간복잡도는 배열의 차원과 관계 없이 $O(1)$이다.

## 누적합의 장점
- 누적합을 미리 계산해두기 때문에 시간 복잡도 측면에서 효율적이다. 
- 만약 어떤 배열에서 [A ~ B] 범위의 구간합을 구해야 한다고 가정해보자.

    ### 1. 누적합을 사용하지 않을 경우
    - A부터 B까지 직접 값들을 더해나가야 하며, 이 경우 0 <= A <= B <= n 이라고 가정했을 때, 최악의 경우 $O(N)$의 시간이 걸리게 된다. 
    - [A ~ B] 범위의 구간합을 m번 구해야 하면 $O(NM)
     $의 시간이 걸리게 된다.

    ### 2. 누적합을 사용하는 경우
    - 누적합을 미리 계산해 두는데, 해당 과정에서 배열 전체를 탐색하기 때문에 우선 $O(N)$의 시간이 필요하다. 
    - 누적합 배열에서 B까지의 누적합과 A-1까지의 누적합을 가져와 계산할 수 있다. 
    - 배열에 2번 접근하므로 $O(1)$의 시간이 소요된다. 
    - [A ~ B] 범위의 구간합을 m번 구해야 하면 $O(N+M)
     $의 시간이 걸리게 된다.

- 따라서 M이 크면 클수록 누적합을 활용하는 것이 시간 복잡도 측면에서 이점을 갖는다.

## 구현
### 누적합
```python
n = int(input())
arr = list(map(int, input().split()))

def calc_prefix_sum(n):
    prefix_sum = [0]*n
    prefix_sum[0] = arr[0]      #맨 처음 값 지정
    for i in range(1, n):
        prefix_sum[i] = prefix_sum[i - 1] + arr[i]
    return prefix_sum
    
prefix_sum = calc_prefix_sum(n)
```
- 시간 복잡도: $O(n)$

### 구간합
```python
n = int(input())
arr = list(map(int, input().split))
i, j = map(int, input().split())

part_sum = prefix_sum[j] - prefix_sum[i - 1]
```
- 시간 복잡도: $O(1)$