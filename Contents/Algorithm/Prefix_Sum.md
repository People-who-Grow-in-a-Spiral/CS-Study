# 누적합 알고리즘(Prefix Sum Algorithm)

## 누적합의 개념
- 수열 An에 대해서 각 인덱스까지의 구간의 합을 구하는 것
- 특정한 배열이 있을 때, 해당 배열까지의 합을 나타내는 말이다. 
- 즉 [1,2,3,4,5] 라는 배열이 있을 때 이 배열의 누적합을 배열로 나타내면 [1,3,6,10,15]가 되는 것이다.(물론 누적합 알고리즘의 구현에 편의를 위해 인덱스가 하나 큰 배열을 만들거나 하는 경우도 있다.)

    ****배열의 값들이 수정되지 않는다는 것을 조건으로 가진다.***

    ### 구간합(Range Sum)
    - 배열의 [A ~ B] 범위의 구간합을 구하고자 할 때, 누적합 배열을 만들어 [B]까지의 누적합에서 [A - 1]까지의 누적합을 빼주면 [A ~ B] 범위의 구간합을 구할 수 있다. 
    - 누적합 배열에 상수 k(배열의 차원에 따라 달라진다)번 접근하여 연산하면 되기 때문에 시간복잡도는 배열의 차원과 관계 없이 O(1)이다.

## 누적합의 장점
- 누적합을 사용할 경우 time complexity의 관점에서 큰 이득을 가져다 준다. 이는 누적합의 경우 미리 계산해둘 수 있기 때문이다. 
<br><br>
- 만약 어떠한 배열에서 a번째 부터 b번째 까지의 수의 합을 알아야 한다고 가정해보자.

    ### 1. 누적합을 사용하지 않을 경우
     a 부터 b 까지 직접 값들을 더해나가야 하며, 이 경우 0<=a<=b<=n에서 최악의 경우 O(N)의 시간이 걸리게 된다. 여기에 이러한 a~b 까지의 합을 구해야 하는 경우가 m번 존재한다면 O(NM)의 시간이 걸리게 된다.

    ### 2. 누적합을 사용하는 경우
    누적합을 사용하려면 먼저 계산이 필요하다. 이 계산 자체가 전체를 탐색해야 하기 때문에 O(N)이 일단 필요하다. 하지만 그 이후 a~b까지의 합은 누적합 배열에서 (b까지의 합) - (a-1 까지의 합)으로 나타낼 수 있다. 즉 O(2) == O(1)로 해결할 수 있게 된다. 이 경우가 m번 존재한다 해도 결국 O(M) 만큼의 시간이 걸릴 것이고 결국 총 O(N+M)만큼 들게 된다.
    
- 따라서 M이 크면 클수록 누적합을 활용하는 것이 O(NM) >= O(N+M)이기에 시간 복잡도에서 큰 이점을 갖는다.

## 구현
### 1. 1차원
1. 1차원 누적합
    ```python
    n = int(input())
    arr = list(map(int, input().split()))

    def calc_prefix_sum(n):
        prefix_sum = [0]*n
        prefix_sum[0] = arr[0]      #맨 처음 값 지정
        for i in range(1, n):
            prefix_sum[i] = prefix_sum[i - 1] + arr[i]
        return prefix_sum
    
    prefix_sum = calc_prefix_sum(n)
    ```
    - 시간 복잡도: O(n)
2. 1차원 구간합
    ```python
    n = int(input())
    arr = list(map(int, input().split))
    i, j = map(int, input().split())

    part_sum = prefix_sum[j] - prefix_sum[i - 1]
    ```
    - 시간 복잡도: O(1)

### 2. 2차원 누적합
1. 2차원 누적합
2. 2차원 구간합